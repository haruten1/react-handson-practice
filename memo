# JavaScriptの基礎知識
主にES6で登場した文法の紹介
- const,let
- テンプレート文字列
- アロー関数とスコープ
```
var tahoe = {
    mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
    print: function(delay=1000) {

    setTimeout(function() {
        console.log(this.mountains.join(","))
    }, delay);

    }
};
```
この場合のthisはtahoeオブジェクトではなく、windowオブジェクトになる。
この解決としてアロー関数でコールバックを記述する。

```
var tahoe = {
    mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
    print: function(delay=1000) {

    setTimeout(
        () => console.log(this.mountains.join(",")),
        delay
    );
    }
};
```
**アロー関数は独自のスコープを持たない**
- デストラクチャリング（分割代入）
- スプレット構文
- Promise,async/await
- クラス宣言

## Javascriptにおける関数型プログラミング
関数型プログラミングとは
```
const numbers = [1, 2, 3, 4, 5];

const doubledNumbers = numbers.map(function (num) {
  return num * 2;
});
```
↑ここでいうmap関数のようなもの
for文のような役割をmap関数に切り出している。
コードが「何をするか」を記述せず、具体的な手順や手続きを指定しない、いわゆる宣言的なプログラミング手法。

特徴として
- 不変性（元のnumbersは変更されない）
- 純粋性（関数が同じ引数に対していつも同じ結果を返す）
- 再帰（ループの代わりに関数内で自分自身の関数を呼びだすことができる）
がある。

# React
React = DOM APIの呼び出しを一手に引き受けるライブラリ

Reactは以下二つのライブラリが最低必要になる。
- React(React要素を作成)
- ReactDOM(React要素をDOMに変換)

## React要素

```
React.createElement("h1", null, "Baked Salmon");
```
は
```
<h1>Baked Salmon</h1>
```
に置換される。

React要素をコンソールに出力すると以下のようになる。
```
Object
    typeof:Symbol(react.element)
    key: null
    props: 
        children: "Baked almon"
        [[Prototype]]: Object
    ref: null
    type: "h1"
    （省略）
    [[Prototype]]: Object
```
propsなどは全てオブジェクトの要素として存在している。

**描画と子要素**
```
const dish = React.createElement("h1", null, "Baked Salmon");
const dessert = React.createElement("h2", null, "Coconut Cream Pie");

ReactDOM.render(
    [dish, dessert],
    document.getElementById('react-container')
);
```
↓
```
<div id="react-container">
    <h1>Baked Salmon</h1>
    <h2>Cream Pie</h2>
</div>
```
↑このようなDOMが作られる。

**関数コンポーネント**
```
function IngredientsList({items}) {
return React.createElement(
    "ul",
    { className: "ingredients" },
    items.map((ingredient, i) =>
    React.createElement("li", { key: i }, ingredient) )
);
}

const items = [
    "1 cup unsalted butter",
    "1 cup crunchy peanut butter",
    "1 cup brown sugar",
    "1 cup white sugar",
    "2 eggs",
    "2.5 cups all purpose flour",
    "1 teaspoon baking powder",
    "0.5 teaspoon salt"
];

ReactDOM.render(
React.createElement(IngredientsList, {items}, null),
document.getElementById("react-container")
);
```
上記のコードはitems配列をli要素に変換している。

本書ではクラスコンポーネントも紹介ている。
クラスコンポーネントは将来的に廃止される予定である。

## jsx
JavascriptにXMLのようなタグベース構文を記述するための言語拡張。
ネストの深いDOMを作る必要がある際、より宣言的な記述ができるようになる。

jsx→js(es)への変換はBabelで行うことができる。

## webpackによるビルド環境構築
webpack = モジュールバンドラ : 異なる種類のファイル（js,jsx.css...）を単一のファイルに結合するためのツール

create appを使わないやり方

```
<!-- package.jsonを作成 -->
npm init -y
<!-- 必要なライブラリをインストール -->
npm install react react-dom serve

<!-- コンポーネント等を追加 -->

<!-- webpackをインストール -->
npm install --save-dev webpack webpack-cli

<!-- jsxコンパイルのためBabelをインストール -->
npm install babel - loader `babel/core --save-dev

<!-- Babelのプリセット（プラグイン）をインストール -->
npm install @babel/present-env `babel/present-react --save-dev

<!-- webpackの実行 -->
npx webpack --mode development

```

```:webpack.config.js
var path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    path: path.join(__dirname, "dist", "assets"),
    filename: "bundle.js",
  },
  devtool: "#source-map",
  module: {
    rules: [
      {
        <!-- 拡張子が.jsのファイルが全て対応になる -->
        test: /\.js$/,
        <!-- 除外するファイル -->
        exclude: /(node_modules)/,
        loader: "babel-loader",
      },
      {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
};

```
webpack.configにビルドの設定を記述。

```:babelrc
<!-- プリセットを指定 -->
{
    "presets": ["@babel/preset-env", "@babel/preset-react"]
}
```
Babelの設定ファイル。

```:package.json
"scripts": {
    "build": "webpack --mode production"
  },
```
package.jsonに記述をしておくと楽。

## フック
フック＝コンポーネントとは独立した関数で、コンポーネントに着脱可能な機能を取り付ける。

### useRef
DOMノードへの参照を保持する。
```
import React, { useRef } from "react";

export default function AddColorForm({ onNewColor = f => f }) {
  const txtTitle = useRef();
  const hexColor = useRef();

  const submit = e => {
    e.preventDefault();
    const title = txtTitle.current.value;
    const color = hexColor.current.value;
    onNewColor(title, color);
    txtTitle.current.value = "";
    hexColor.current.value = "";
  };

<!-- refプロパティにrefオブジェクトを指定 -->
  return (
    <form onSubmit={submit}>
      <input ref={txtTitle} type="text" placeholder="color title..." required />
      <input ref={hexColor} type="color" required />
      <button>ADD</button>
    </form>
  );
}
```
ref＝{}にrefオブジェクトを指定することで、refのcurrentフィールド経由でDOMに直接アクセスできるようになる。
しかし、このコードのようにDOMに直接アクセスして書き換えるようなコンポーネントは「制御されていないコンポーネント」と呼ばれ、推奨されない。

```
import React, { useState } from "react";

export default function AddColorForm({ onNewColor = f => f }) {
  const [title, setTitle] = useState("");
  const [color, setColor] = useState("#000000");

  const submit = e => {
    e.preventDefault();
    onNewColor(title, color);
    setTitle("");
    setColor("");
  };

  return (
    <form onSubmit={submit}>
      <input
        value={title}
        onChange={event => setTitle(event.target.value)}
        type="text"
        placeholder="color title..."
        required
      />
      <input
        value={color}
        onChange={event => setColor(event.target.value)}
        type="color"
        required
      />
      <button>ADD</button>
    </form>
  );
}
```
上記はrefの代わりにstateでvalueを管理している。
inputに値を入力するたびにstateが更新される仕組み＝制御されたコンポーネント。

## カスタムフック
複数のコンポーネントで重複した関数を切り出したもの。
```
import { useState } from "react";

export const useInput = initialValue => {
  const [value, setValue] = useState(initialValue);
  return [
    { value, onChange: e => setValue(e.target.value) },
    () => setValue(initialValue)
  ];
};
```
↑stateの値とstateを更新する関数のみを切り出したもの。
stateの初期値を受け取り、配列を戻り値として返却する。

```
import React from "react";
import { useInput } from "./hooks";

export default function AddColorForm({ onNewColor = f => f }) {
  const [titleProps, resetTitle] = useInput("");
  const [colorProps, resetColor] = useInput("#000000");

  const submit = e => {
    e.preventDefault();
    onNewColor(titleProps.value, colorProps.value);
    resetTitle();
    resetColor();
  };

  return (
    <form onSubmit={submit}>
      <input
        {...titleProps}
        type="text"
        placeholder="color title..."
        required
      />
      <input {...colorProps} type="color" required />
      <button>ADD</button>
    </form>
  );
}

```
↑useStateを呼び出す代わりにuseInputを呼び出している。
{...titleProps}の箇所で、スプレッド構文によりvalueとonChange要素がinputに設定されます。
onSubmitのresetTitle()により、フォーム送信後に初期化を行うこともできる。

カスタムフック内部で別のフックを呼び出した場合、呼び出し元のコンポーネントが際描画される。

### Reactコンテキスト
ステートをルートコンポーネントで一括管理するのが理想だが、コンポーネントの階層が深くなるほど上位から下位へ多くのコンポーネントを経由してデータを受け渡しする必要ができてしまう。
それを解決するのが**コンテキスト**。

```
import React, { createContext } from "react";
import colors from "./color-data";
import { render } from "react-dom";
import App from "./App";

export const ColorContext = createContext();

render(
  <ColorContext.Provider value={{ colors }}>
    <App />
  </ColorContext.Provider>,
  document.getElementById("root")
);
```
createContextを用いてコンテキストを作成する。
Context.Provider=データの提供元
Context.Consumer＝データの受け渡し先

Context.Providerで囲ったコンポーネント以下の全てのコンポーネントに直接value={{ colors }}の受け渡しを行うことができる。

```
import React, { useContext } from "react";
import Color from "./Color";
import { ColorContext } from "./";

export default function ColorList() {
  const { colors } = useContext(ColorContext);

  if (!colors.length) return <div>No Colors Listed. (Add a Color)</div>;

  return (
    <div>
      {colors.map(color => (
        <Color key={color.id} {...color} />
      ))}
    </div>
  );
}
```
const { colors } = useContext(ColorContext);
でcolorsを直接取得している。

### コンテキストとstateの併用
```
import React, { createContext, useState } from "react";
import colorData from "./color-data.json";
import { v4 } from "uuid";

export const ColorContext = createContext();

export default function ColorProvider({ children }) {
  const [colors, setColors] = useState(colorData);

  const addColor = (title, color) =>
    setColors([
      ...colors,
      {
        id: v4(),
        rating: 0,
        title,
        color
      }
    ]);

  const rateColor = (id, rating) =>
    setColors(
      colors.map(color => (color.id === id ? { ...color, rating } : color))
    );

  const removeColor = id => setColors(colors.filter(color => color.id !== id));

  return (
    <ColorContext.Provider value={{ colors, addColor, removeColor, rateColor }}>
      {children}
    </ColorContext.Provider>
  );
}
```
value={{ colors, addColor, removeColor, rateColor }}>
により、配下のコンポーネントでstateの値とその更新を行うことができる。
setColorsそのものを共有するのではなく、必要な処理（addColorなど）を提供することで、不要なバグを防ぐことができる。

### useEffect
```
function WordCount({ children = "" }) {
  useAnyKeyToRender();

  // 毎回異なるインスタンスが生成される
  const words = children.split(" ");

  useEffect(() => {
    console.log("fresh render");
  }, [words]);

  return (
    <>
      <p>{children}</p>
      <p>
        <strong>{words.length} - words</strong>
      </p>
    </>
  );
}
```
wordsはレンダリングのたびに再生成されるので、useEffectもレンダリングのたびに実行されてしまう。
これを回避するには
①関数の外で依存配列を宣言する（性的な文字列）
②useMemoを宣言する（関数など）

### useMemo
```
function WordCount({ children = "" }) {
  useAnyKeyToRender();

  // useMemoによるメモ化
  const words = useMemo(() => children.split(" "), [children]);

  useEffect(() => {
    console.log("fresh render");
  }, [words]);

  return (
    <>
      <p>{children}</p>
      <p>
        <strong>{words.length} - words</strong>
      </p>
    </>
  );
}
```
 const words = useMemo(() => children.split(" "), [children]);

 依存配列**children**に変更がない限り.splitは実行されず、wordsにはキャッシュされた値が代入される。
 wordsは同一であることが保証される。

 ### useCallback
 useMemoは関数の返り値をキャッシュするが、useCallbackは関数自体をキャッシュする。
 ```
 // useCallbackによるメモ化
  const fn = useCallback(() => {
    console.log("hello");
    console.log("world");
  }, []);

  useEffect(() => {
    console.log("fresh render");
    fn();
  }, [fn]);
 ```

 ### useLayoutEffect
 1. コンポーネントの描画関数が呼び出される
 1. useLayoutEffectが実行される
 1. ブラウザのPaint処理で描画結果が画面に反映される
 1. useEffectが実行される

 useLayoutEffect＝関数実行〜描画の間に実行できる

 ```
 function useWindowSize() {
  const [width, setWidth] = useState(0);
  const [height, setHeight] = useState(0);

  const resize = () => {
    setWidth(window.innerWidth);
    setHeight(window.innerHeight);
  };

  useLayoutEffect(() => {
    window.addEventListener("resize", resize);
    resize();
    return () => window.removeEventListener("resize", resize);
  }, []);

  return [width, height];
}
 ```
 上記はブラウザの大きさを測定する関数。
 useLayoutEffectを利用することで描画前にブラウザの大きさを返すことができる。

 ### useReducer
 ```
function Checkbox() {
  const [checked, setChecked] = useState(false);

  function toggle() {
    setChecked(checked => !checked);
  }

  return (
    <>
      <input type="checkbox" value={checked} onChange={toggle} />
      {checked ? "checked" : "not checked"}
    </>
  );
}
 ```
はuseReducerを使うと
```
function Checkbox() {
  const [checked, toggle] = useReducer(checked => !checked, false);

  return (
    <>
      <input type="checkbox" value={checked} onChange={toggle} />
      {checked ? "checked" : "not checked"}
    </>
  );
}
```
とできる。
useReducerの返り値は1つ目がステート値で二つ目がレデューサ関数。

## データ
